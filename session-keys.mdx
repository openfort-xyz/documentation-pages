export const description =
  'In this guide, we will talk about session keys. First a general overview and then we will show their role in Openfort.'

# Session Keys

In the realm of web3 games, session keys can be a crucial aspect for securing player accounts as well as improving the overall gaming experience. Session keys can be used to authenticate players, authorize their actions within the game, and grant limited permissions to their web3 accounts.

## Overview

Openfort has developed a robust internal infrastructure for handling session keys, ensuring secure and seamless player authentication. This infrastructure includes automated systems for generating, handling, and validating session keys, all managed through Openfort's API.

Session keys are cryptographic keys used to establish a secure connection between a player's device, the game server and the user's web3 account. They are generated inside the player's device and are used to authenticate requests from the player. Session keys are short-lived and typically expire after a certain period of inactivity or when the player logs out.

## How Session Keys Work

When players sign up or log into the game, they can generate a session key for that device. The session key is then securely notified to the game server and is registered in the player's web3 account (aka smart contract wallet) all using Openfort's API. Subsequent requests from the player's device to the game use the specific authentication mechanism of each game together with the user's session key. Openfort's infrastructure validates the session key and verifies the player's identity before processing the request.

![SessionKeys.excalidraw.svg](https://blog-cms.openfort.xyz/uploads/How_session_keys_work_1_aa70263ef3.svg)

Incorporating session keys into web3 games offers several advantages:

**1. Enhanced security:** fundamentally two big security improvements: they eliminate the need to store (and protect) the private keys of the account on the device and add permission granularity to web3 accounts to bring limited authorization. Such security enhancements mitigate the risks of key or asset theft.

**2. Reduced transaction signing:** If players are authenitcated using their wallet (such as Metamask) when generating their session keys, they only need to sign one transaction to register that key. From now on, they will start using it for each interaction as opposed to signing each time for every action.

**3. Improved user experience:** With fewer transactions to sign, users can enjoy a smoother and quicker experience when interacting with a dApp.


## Session Keys' Lifecycle

To create and manage session keys in your game, follow these steps:
- When players log in, they should generate a session key on their device and send it to your game server.
- The sensitive part of the session key (session private key) is always securely stored on the player's device and should never be disclosed.
- The player should include the public part of the session key in subsequent requests from the player's device to the game server for authentication. Such requests should be digitally signed by the secret part of the session key.
- On the game server, validate the session key and the signature before processing the request.
- Periodically refresh the session key during the player's session to maintain security.
- Players can invalidate the session key whenever they want, e.g.: after logging out or after a certain period of inactivity.

## Registering Session Keys

As indicated above, a player can register new session keys through the following Openfort API endpoint.
The first example below shows the call to register a session key for a player using a custodial account.
As they do not hold the private key of the administrator/owner wallet, no further actions are required from the player.

<CodeGroup title="Register a session key (custodial accounts)" tag="POST" label="/v1/sessions">
  ```bash {{ title: 'cURL' }}
    curl https://api.openfort.xyz/v1/sessions \
    -H "Authorization: Bearer $YOUR_SECRET_KEY" \
    -d player=pla_... \
    -d address=0x76e6...9341 \
    -d chain_id=80001 \
    -d valid_until=1700000000 \
    -d valid_after=1650000000 \
    -d policy=pol_...
  ```
</CodeGroup>

The second example below, is an example of the API call that players with non-custodial accounts would use.
Notice the extra `external_owner_address` parameter needed to indicate the actual [EOA](https://ethereum.org/en/developers/docs/accounts/) that will sign the authorization of the action.
As they hold the private key of the administrator/owner wallet, the response of such call would contain an extra
element called `next_action` which will need to be signed by the players EOA and returned in a successive API call.

<CodeGroup title="Register a session key (non-custodial accounts)" tag="POST" label="/v1/sessions">
  ```bash {{ title: 'cURL' }}
    curl https://api.openfort.xyz/v1/sessions \
    -H "Authorization: Bearer $YOUR_SECRET_KEY" \
    -d player=pla_... \
    -d address=0x76e6...9341 \
    -d chain_id=80001 \
    -d valid_until=1700000000 \
    -d valid_after=1650000000 \
    -d policy=pol_...
    -d external_owner_address=0x8a16...CE4a
  ```
</CodeGroup>

Once the content of the `next_action` parameter above is signed by the player's wallet,
it has to be sent using the endpoint `/v1/sessions/:session/signature` as shown below:

<CodeGroup title="Request" tag="POST" label="/v1/sessions/:session/signature">
  ```bash {{ title: 'cURL' }}
    curl https://api.openfort.xyz/v1/sessions/ses_.../signature \
    -H "Authorization: Bearer $YOUR_PUBLISHABLE_KEY" \
    -d "signature=xyz..."
  ```
</CodeGroup>

For more information about how to use the sesion key endpoints, you can visit our [API documentation](https://www.openfort.xyz/docs/api/sessions).
